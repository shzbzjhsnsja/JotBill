import { webview } from '@kit.ArkWeb';
import { textRecognition } from '@kit.CoreVisionKit';
import { image } from '@kit.ImageKit';
import { picker, fileIo as fs } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { http } from '@kit.NetworkKit';
import { util } from '@kit.ArkTS';
import { promptAction } from '@kit.ArkUI';

// 1. åˆå§‹åŒ–æŒä¹…åŒ–å­˜å‚¨
PersistentStorage.persistProp('hasAgreedPrivacy', false);

// ==========================================
// éšç§æ”¿ç­–å¼¹çª—ç»„ä»¶
// ==========================================
@CustomDialog
struct PrivacyDialog {
  controller: CustomDialogController
  confirm: () => void = () => {}
  cancel: () => void = () => {}

  build() {
    Column() {
      Text('æ¬¢è¿ä½¿ç”¨å°è®°ä¸€ç¬”')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 24, bottom: 12 })

      Text('    è¯·æ‚¨åœ¨ä½¿ç”¨å‰ä»”ç»†é˜…è¯»ã€Šç”¨æˆ·åè®®ã€‹ä¸ã€Šéšç§æ”¿ç­–ã€‹ã€‚\n    æˆ‘ä»¬éœ€è¦è®¿é—®æ‚¨çš„ç›¸å†Œå›¾ç‰‡è¿›è¡Œå°ç¥¨è¯†åˆ«ä¸å¤´åƒè®¾ç½®ï¼Œä½¿ç”¨ç½‘ç»œè¿æ¥æ‚¨çš„ WebDAV è¿›è¡Œæ•°æ®å¤‡ä»½ã€è·å–å®æ—¶æ±‡ç‡ï¼Œä»¥åŠè¿æ¥ DeepSeek è¿›è¡Œæ™ºèƒ½åˆ†æã€‚')
        .fontSize(16)
        .fontColor('#333333')
        .margin({ bottom: 20, left: 20, right: 20 })
        .lineHeight(24)

      Text('ç‚¹å‡»é˜…è¯»è¯¦ç»†éšç§æ”¿ç­– >>')
        .fontSize(14)
        .fontColor('#0A59F7')
        .onClick(() => {
          const context = getContext(this) as common.UIAbilityContext;
          context.startAbility({
            action: 'ohos.want.action.viewData',
            entities: ['entity.system.browsable'],
            uri: 'https://wvd4r1fvutb.feishu.cn/wiki/EhTFwM3GCimFp3kynEWcpVudnUi?from=from_copylink'
          });
        })
        .margin({ bottom: 30 })

      Row() {
        Button('ä¸åŒæ„å¹¶é€€å‡º')
          .fontColor('#666666')
          .backgroundColor('#F2F2F2')
          .onClick(() => {
            this.cancel()
            if (this.controller) {
              this.controller.close()
            }
          })
          .width('40%')
          .height(40)

        Button('åŒæ„å¹¶ç»§ç»­')
          .fontColor(Color.White)
          .backgroundColor('#0A59F7')
          .onClick(() => {
            if (this.controller) {
              this.controller.close()
            }
            this.confirm()
          })
          .width('40%')
          .height(40)
      }
      .justifyContent(FlexAlign.SpaceEvenly)
      .width('100%')
      .margin({ bottom: 24 })
    }
    .backgroundColor(Color.White)
    .borderRadius(24)
    .width('90%')
  }
}

// Bridge æ¥å£å®šä¹‰
interface JotBillBridge {
  triggerOCR: () => void;
  saveFile: (fileName: string, content: string) => void;
  importFile: () => void;
  davAction: (action: string, host: string, path: string, user: string, pass: string, body: string, insecure: string, cbId: string) => void;
  testConnection: () => string;
  exitApp: () => void;
}

class WebResult {
  ok: boolean = false;
  message: string = "";
}

interface IRenderExitedEvent {
  renderExitReason: number;
}

@Entry
@Component
struct Index {
  @State isLocalLoad: boolean = false;
  // âš ï¸ è®°å¾—æ‰“åŒ…å‰ç¡®è®¤è¿™é‡Œæ˜¯å¦éœ€è¦æ”¹å› rawfile æˆ–è€…æ˜¯è¿œç¨‹åœ°å€
  @State remoteUrl: string = 'http://10.0.0.103:5173/';

  @State lastExitRequestTime: number = 0;

  private webController: webview.WebviewController = new webview.WebviewController();

  @StorageLink('hasAgreedPrivacy') hasAgreed: boolean = false;

  dialogController: CustomDialogController = new CustomDialogController({
    builder: PrivacyDialog({
      cancel: () => { this.onPrivacyCancel() },
      confirm: () => { this.onPrivacyConfirm() }
    }),
    autoCancel: false,
    alignment: DialogAlignment.Center,
    customStyle: false,
    cancel: () => { this.onPrivacyCancel() }
  })

  aboutToAppear() {
    if (!this.hasAgreed) {
      this.dialogController.open();
    } else {
      console.info('ç”¨æˆ·ä¹‹å‰å·²åŒæ„éšç§åè®®ï¼Œä¸å†å¼¹çª—');
    }
  }

  // =======================================================
  // æ ¸å¿ƒä¿®å¤ï¼šç‰©ç†è¿”å›é”®å¤„ç† (é˜²ç»•è¿‡éšç§å¼¹çª—)
  // =======================================================
  onBackPress() {
    // 1. å¦‚æœæ²¡åŒæ„åè®®ï¼ŒæŒ‰è¿”å›é”®ç›´æ¥æ€è¿›ç¨‹
    if (!this.hasAgreed) {
      this.onPrivacyCancel();
      return true;
    }

    // 2. æ­£å¸¸è¿”å›é€»è¾‘
    this.webController.runJavaScript('if(window.dispatchBackKey) window.dispatchBackKey();');
    return true;
  }

  handleAppExit() {
    const currentTime = new Date().getTime();
    if (currentTime - this.lastExitRequestTime < 2000) {
      const context = getContext(this) as common.UIAbilityContext;
      context.terminateSelf();
    } else {
      this.lastExitRequestTime = currentTime;
      promptAction.showToast({
        message: 'å†æŒ‰ä¸€æ¬¡é€€å‡ºåº”ç”¨',
        duration: 2000,
        bottom: 100
      });
    }
  }

  onPrivacyCancel() {
    const context = getContext(this) as common.UIAbilityContext;
    context.terminateSelf();
  }

  onPrivacyConfirm() {
    this.hasAgreed = true;
    console.info('ç”¨æˆ·é¦–æ¬¡åŒæ„éšç§åè®®');
  }

  private jsBridgeProxy: JotBillBridge = {
    triggerOCR: () => { this.realOCRLogic(); },
    saveFile: (f, c) => { this.handleSaveFile(f, c); },
    importFile: () => { this.handleImportFile(); },
    davAction: (action, host, path, user, pass, body, insecure, cbId) => {
      this.handleWebDAV(action, host, path, user, pass, body, cbId);
    },
    testConnection: () => { return "é¸¿è’™åŸç”Ÿç«¯åœ¨çº¿"; },
    exitApp: () => { this.handleAppExit(); }
  }

  build() {
    Column() {
      Web({
        src: this.isLocalLoad ? $rawfile('index.html') : this.remoteUrl,
        controller: this.webController
      })
        .javaScriptAccess(true)
        .domStorageAccess(true)
        .databaseAccess(true)
        .fileAccess(true)
        .imageAccess(true)
        .onlineImageAccess(true)
        .javaScriptProxy({
          object: this.jsBridgeProxy,
          name: "JotBillOCR",
          methodList: ["triggerOCR", "saveFile", "importFile", "davAction", "testConnection", "exitApp"],
          controller: this.webController
        })
        .onRenderExited((event: IRenderExitedEvent) => {
          console.error('[Webview] æ¸²æŸ“è¿›ç¨‹å´©æºƒ/é€€å‡º Reason Code: ' + event.renderExitReason);
          if (this.webController) {
            this.webController.loadUrl(this.isLocalLoad ? $rawfile('index.html') : this.remoteUrl);
          }
        })
        .width('100%')
        .height('100%')
    }
  }

  async handleImportFile() {
    try {
      const documentSelectOptions = new picker.DocumentSelectOptions();
      documentSelectOptions.maxSelectNumber = 1;
      documentSelectOptions.fileSuffixFilters = ['.json', '.txt', '*'];

      const documentViewPicker = new picker.DocumentViewPicker();
      const documentSelectResult = await documentViewPicker.select(documentSelectOptions);

      if (documentSelectResult && documentSelectResult.length > 0) {
        const uri = documentSelectResult[0];
        const file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
        const arrayBuffer = new ArrayBuffer(4096000);
        const readLen = fs.readSync(file.fd, arrayBuffer);
        const content = util.TextDecoder.create('utf-8', { ignoreBOM: true }).decodeWithStream(new Uint8Array(arrayBuffer.slice(0, readLen)));
        fs.closeSync(file);
        this.webController.runJavaScript(`if(window.onNativeImportSuccess) window.onNativeImportSuccess(${JSON.stringify(content)});`);
      }
    } catch (err) {
      let e = err as BusinessError;
      this.webController.runJavaScript(`alert('å¯¼å…¥å‡ºé”™: ${e.message}');`);
    }
  }

  // =======================================================
  // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šWebDAV é€»è¾‘å¢å¼º ğŸ”¥ğŸ”¥ğŸ”¥
  // =======================================================
  async handleWebDAV(action: string, host: string, pathStr: string, user: string, pass: string, body: string, cbId: string) {
    console.info(`[JotBill-DAV] Action: ${action}, Path: ${pathStr}`);
    try {
      let fullUrl = host;
      if (!fullUrl.endsWith('/')) fullUrl += '/';

      if (pathStr) {
        let cleanPath = pathStr.startsWith('/') ? pathStr.substring(1) : pathStr;
        // ğŸ”¥ ä¿®å¤ï¼šå¯¹è·¯å¾„è¿›è¡Œç¼–ç ï¼Œé˜²æ­¢ä¸­æ–‡è·¯å¾„æŠ¥é”™
        cleanPath = encodeURI(cleanPath);
        fullUrl += cleanPath;
      }

      let method = http.RequestMethod.GET;
      if (action === 'TEST') {
        method = http.RequestMethod.GET;
      } else if (action === 'UPLOAD') {
        method = http.RequestMethod.PUT;
        if (!fullUrl.toLowerCase().endsWith('.json')) {
          if (!fullUrl.endsWith('/')) fullUrl += '/';
          fullUrl += 'backup_data.json';
        }
      } else if (action === 'RESTORE') {
        method = http.RequestMethod.GET;
        if (!fullUrl.toLowerCase().endsWith('.json')) {
          if (!fullUrl.endsWith('/')) fullUrl += '/';
          fullUrl += 'backup_data.json';
        }
      }

      let textEncoder = new util.TextEncoder();
      let authArr = textEncoder.encodeInto(`${user}:${pass}`);
      let base64Helper = new util.Base64Helper();
      let authBase64 = base64Helper.encodeToStringSync(authArr);

      let httpRequest = http.createHttp();
      let myHeaders: Record<string, string> = {
        'Authorization': `Basic ${authBase64}`,
        'Content-Type': 'application/json'
      };

      let options: http.HttpRequestOptions = {
        method: method, header: myHeaders, expectDataType: http.HttpDataType.STRING, priority: 1
      };
      if (action === 'UPLOAD' && body) options.extraData = body;

      const response = await httpRequest.request(fullUrl, options);

      // ğŸ”¥ğŸ”¥ğŸ”¥ æ ¸å¿ƒä¿®å¤ï¼šå…è®¸ 403/409/405 é€šè¿‡æµ‹è¯• ğŸ”¥ğŸ”¥ğŸ”¥
      // åªè¦ä¸æ˜¯ 401 (å¯†ç é”™)ï¼Œå…¶ä»–çŠ¶æ€ç åœ¨æµ‹è¯•è¿æ¥æ—¶éƒ½ç®—æˆåŠŸ
      const isSuccess = (response.responseCode >= 200 && response.responseCode < 300);
      const isTestAllowed = action === 'TEST' && (
        response.responseCode === 405 ||
          response.responseCode === 403 || // å…è®¸ Forbidden (åšæœäº‘æ ¹ç›®å½•åˆ—è¡¨ç¦æ­¢)
          response.responseCode === 409    // å…è®¸ Conflict
      );

      if (isSuccess || isTestAllowed) {
        let successMsg = "Success";
        if (action === 'RESTORE') successMsg = typeof response.result === 'string' ? response.result : JSON.stringify(response.result);
        this.replyWebDAV(cbId, true, successMsg);
      } else {
        // åªæœ‰ 401 æˆ–å…¶ä»–é”™è¯¯æ‰æŠ¥å¤±è´¥
        this.replyWebDAV(cbId, false, `HTTP Error: ${response.responseCode}`);
      }
    } catch (err) {
      let e = err as BusinessError;
      this.replyWebDAV(cbId, false, `Network Error: ${e.message}`);
    }
  }

  replyWebDAV(cbId: string, ok: boolean, message: string) {
    let payload = new WebResult();
    payload.ok = ok;
    payload.message = message;
    this.webController.runJavaScript(`if(window.__DAV_CB) window.__DAV_CB('${cbId}', ${JSON.stringify(payload)})`);
  }

  async realOCRLogic() {
    let file: fs.File | undefined = undefined;
    let imageSource: image.ImageSource | undefined = undefined;
    let pixelMap: image.PixelMap | undefined = undefined;

    try {
      const photoSelectOptions = new picker.PhotoSelectOptions();
      photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;
      photoSelectOptions.maxSelectNumber = 1;
      const photoViewPicker = new picker.PhotoViewPicker();

      const result = await photoViewPicker.select(photoSelectOptions);
      if (result.photoUris.length === 0) {
        this.webController.runJavaScript(`if(window.receiveOCRResult) window.receiveOCRResult('CANCEL');`);
        return;
      }
      file = fs.openSync(result.photoUris[0], fs.OpenMode.READ_ONLY);
      imageSource = image.createImageSource(file.fd);
      pixelMap = await imageSource.createPixelMap();

      const ocrPromise = textRecognition.recognizeText({ pixelMap: pixelMap });
      const timeoutPromise = new Promise<textRecognition.TextRecognitionResult>((_, reject) =>
      setTimeout(() => reject(new Error("OCRè¶…æ—¶(5s)")), 5000)
      );

      const ocrResult = await Promise.race([ocrPromise, timeoutPromise]);
      let recognizedText = ocrResult.value;

      if (!recognizedText) recognizedText = "æœªè¯†åˆ«åˆ°æ–‡å­—";
      const safeText = JSON.stringify(recognizedText);
      this.webController.runJavaScript(`receiveOCRResult(${safeText})`);

    } catch (error) {
      let err = error as BusinessError;
      let errorMsg = err.message || JSON.stringify(error);

      AlertDialog.show({
        title: 'è¯†åˆ«å¤±è´¥',
        message: `é”™è¯¯: ${errorMsg}\n(æç¤º: è¯†åˆ«æœåŠ¡æš‚ä¸å¯ç”¨ï¼Œè¯·æ‰‹åŠ¨è®°è´¦)`,
        confirm: { value: 'å…³é—­', action: () => {} }
      });

      let safeMsg = errorMsg.replace(/'/g, "\\'");
      this.webController.runJavaScript(`alert('${safeMsg}'); if(window.receiveOCRResult) window.receiveOCRResult('ERROR');`);

    } finally {
      try {
        if (imageSource) imageSource.release();
        if (pixelMap) pixelMap.release();
        if (file) fs.closeSync(file);
      } catch (e) {}
    }
  }

  async handleSaveFile(fileName: string, content: string) {
    try {
      const documentSaveOptions = new picker.DocumentSaveOptions();
      documentSaveOptions.newFileNames = [fileName];
      const documentViewPicker = new picker.DocumentViewPicker();
      const documentSaveResult = await documentViewPicker.save(documentSaveOptions);
      if (documentSaveResult.length > 0) {
        const file = fs.openSync(documentSaveResult[0], fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE | fs.OpenMode.TRUNC);
        fs.writeSync(file.fd, content, { encoding: 'utf-8' });
        fs.closeSync(file);

        promptAction.showToast({
          message: 'å¯¼å‡ºæˆåŠŸï¼æ–‡ä»¶å·²ä¿å­˜',
          duration: 3000
        });
        this.webController.runJavaScript(`alert('âœ… å¤‡ä»½å¯¼å‡ºæˆåŠŸï¼');`);
      }
    } catch (error) {
      let err = error as BusinessError;
      this.webController.runJavaScript(`alert('å¯¼å‡ºå¤±è´¥: ${err.message}');`);
    }
  }
}