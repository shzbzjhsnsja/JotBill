import { webview } from '@kit.ArkWeb';
import { textRecognition } from '@kit.CoreVisionKit';
import { image } from '@kit.ImageKit';
import { picker, fileIo as fs } from '@kit.CoreFileKit';
import { common } from '@kit.AbilityKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { http } from '@kit.NetworkKit';
import { util } from '@kit.ArkTS';

interface JotBillBridge {
  triggerOCR: () => void;
  saveFile: (fileName: string, content: string) => void;
  davAction: (action: string, host: string, path: string, user: string, pass: string, body: string, insecure: string, cbId: string) => void;
  testConnection: () => string;
}

class WebResult {
  ok: boolean = false;
  message: string = "";
}

@Entry
@Component
struct Index {
  @State isLocalLoad: boolean = false;
  // âš ï¸ ç¡®è®¤ IP
  @State remoteUrl: string = 'http://10.0.0.103:3000/';

  private controller: webview.WebviewController = new webview.WebviewController();

  private jsBridgeProxy: JotBillBridge = {
    triggerOCR: () => { this.selectImageAndRecognize(); },
    saveFile: (f, c) => { this.handleSaveFile(f, c); },
    davAction: (action, host, path, user, pass, body, insecure, cbId) => {
      this.handleWebDAV(action, host, path, user, pass, body, cbId);
    },
    testConnection: () => { return "é¸¿è’™åœ¨çº¿"; }
  }

  build() {
    Column() {
      Web({
        src: this.isLocalLoad ? $rawfile('index.html') : this.remoteUrl,
        controller: this.controller
      })
        .javaScriptAccess(true)
        .domStorageAccess(true)
        .javaScriptProxy({
          object: this.jsBridgeProxy,
          name: "JotBillOCR",
          methodList: ["triggerOCR", "saveFile", "davAction", "testConnection"],
          controller: this.controller
        })
        .width('100%')
        .height('100%')
    }
  }

  // =======================================================
  // åŠŸèƒ½ A: WebDAV æ ¸å¿ƒ (æ™ºèƒ½æ–‡ä»¶åå…œåº•)
  // =======================================================
  async handleWebDAV(action: string, host: string, pathStr: string, user: string, pass: string, body: string, cbId: string) {
    console.info(`[JotBill-DAV] Action: ${action}, Path: ${pathStr}`);

    try {
      // 1. åŸºç¡€ URL
      let fullUrl = host;
      if (!fullUrl.endsWith('/')) fullUrl += '/';

      // æ‹¼æ¥è·¯å¾„
      if (pathStr) {
        let cleanPath = pathStr.startsWith('/') ? pathStr.substring(1) : pathStr;
        fullUrl += cleanPath;
      }

      // 2. HTTP æ–¹æ³•ä¸æ™ºèƒ½æ–‡ä»¶åä¿®æ­£
      let method = http.RequestMethod.GET;

      if (action === 'TEST') {
        method = http.RequestMethod.GET;
      }
      else if (action === 'UPLOAD') {
        method = http.RequestMethod.PUT;

        // ğŸŸ¢ğŸŸ¢ğŸŸ¢ æ™ºèƒ½ä¿®æ­£é€»è¾‘ ğŸŸ¢ğŸŸ¢ğŸŸ¢
        // å¦‚æœè·¯å¾„ä¸æ˜¯ä»¥ .json ç»“å°¾ï¼Œè¯´æ˜ Web ç«¯åªä¼ äº†ç›®å½•ï¼Œæ²¡ä¼ æ–‡ä»¶å
        // è¿™æ—¶å€™æˆ‘ä»¬å¼ºåˆ¶åŠ ä¸Šé»˜è®¤æ–‡ä»¶åï¼Œé˜²æ­¢æŠ¥ 405
        if (!fullUrl.toLowerCase().endsWith('.json')) {
          if (!fullUrl.endsWith('/')) fullUrl += '/';
          fullUrl += 'backup_data.json';
          console.info('[JotBill-DAV] è‡ªåŠ¨è¿½åŠ é»˜è®¤æ–‡ä»¶å: ' + fullUrl);
        }
      }
      else if (action === 'RESTORE') {
        method = http.RequestMethod.GET;
        // æ¢å¤æ—¶åŒç†ï¼Œå¦‚æœæ²¡æŒ‡å®šå…·ä½“æ–‡ä»¶ï¼Œå°±æ‰¾é»˜è®¤æ–‡ä»¶
        if (!fullUrl.toLowerCase().endsWith('.json')) {
          if (!fullUrl.endsWith('/')) fullUrl += '/';
          fullUrl += 'backup_data.json';
        }
      }

      // 3. Auth
      let textEncoder = new util.TextEncoder();
      let authArr = textEncoder.encodeInto(`${user}:${pass}`);
      let base64Helper = new util.Base64Helper();
      let authBase64 = base64Helper.encodeToStringSync(authArr);

      // 4. Headers
      let httpRequest = http.createHttp();
      let myHeaders: Record<string, string> = {
        'Authorization': `Basic ${authBase64}`,
        'Content-Type': 'application/json'
      };

      let options: http.HttpRequestOptions = {
        method: method,
        header: myHeaders,
        expectDataType: http.HttpDataType.STRING,
        priority: 1
      };

      if (action === 'UPLOAD' && body) {
        options.extraData = body;
      }

      console.info(`[JotBill-DAV] Sending ${method} to ${fullUrl}`);
      const response = await httpRequest.request(fullUrl, options);
      console.info(`[JotBill-DAV] Response Code: ${response.responseCode}`);

      // 5. ç»“æœåˆ¤å®š
      // 405 ä»…åœ¨æµ‹è¯•ç›®å½•æ—¶ç®—é€šè¿‡
      if ((response.responseCode >= 200 && response.responseCode < 300) || (action === 'TEST' && response.responseCode === 405)) {
        let successMsg = "Success";
        if (action === 'RESTORE') {
          if (typeof response.result === 'string') successMsg = response.result;
          else successMsg = JSON.stringify(response.result);
        }
        this.replyWebDAV(cbId, true, successMsg);
      } else {
        this.replyWebDAV(cbId, false, `HTTP Error: ${response.responseCode}`);
      }

    } catch (err) {
      let e = err as BusinessError;
      this.replyWebDAV(cbId, false, `Network Error: ${e.message}`);
    }
  }

  replyWebDAV(cbId: string, ok: boolean, message: string) {
    let payload = new WebResult();
    payload.ok = ok;
    payload.message = message;
    let jsonStr = JSON.stringify(payload);
    this.controller.runJavaScript(`if(window.__DAV_CB) window.__DAV_CB('${cbId}', ${jsonStr})`);
  }

  // === OCR (ä¿ç•™) ===
  async selectImageAndRecognize() {
    this.realOCRLogic();
  }

  async realOCRLogic() {
    try {
      const photoSelectOptions = new picker.PhotoSelectOptions();
      photoSelectOptions.MIMEType = picker.PhotoViewMIMETypes.IMAGE_TYPE;
      photoSelectOptions.maxSelectNumber = 1;
      const photoViewPicker = new picker.PhotoViewPicker();

      const result = await photoViewPicker.select(photoSelectOptions);
      if (result.photoUris.length === 0) {
        this.controller.runJavaScript(`if(window.receiveOCRResult) window.receiveOCRResult('CANCEL');`);
        return;
      }

      const uri = result.photoUris[0];
      let file = fs.openSync(uri, fs.OpenMode.READ_ONLY);
      let imageSource = image.createImageSource(file.fd);
      let pixelMap = await imageSource.createPixelMap();

      const ocrPromise = textRecognition.recognizeText({ pixelMap: pixelMap });
      const timeoutPromise = new Promise<textRecognition.TextRecognitionResult>((_, reject) =>
      setTimeout(() => reject(new Error("OCRè¶…æ—¶")), 5000)
      );

      const ocrResult = await Promise.race([ocrPromise, timeoutPromise]);
      let recognizedText = ocrResult.value || "æœªè¯†åˆ«åˆ°æ–‡å­—";
      const safeText = JSON.stringify(recognizedText);
      this.controller.runJavaScript(`receiveOCRResult(${safeText})`);

      imageSource.release();
      pixelMap.release();
      fs.closeSync(file);

    } catch (e) {
      let err = e as BusinessError;
      this.controller.runJavaScript(`alert('${err.message}'); if(window.receiveOCRResult) window.receiveOCRResult('ERROR');`);
    }
  }

  // === å¯¼å‡º (ä¿ç•™) ===
  async handleSaveFile(fileName: string, content: string) {
    try {
      const documentSaveOptions = new picker.DocumentSaveOptions();
      documentSaveOptions.newFileNames = [fileName];
      const documentViewPicker = new picker.DocumentViewPicker();
      const documentSaveResult = await documentViewPicker.save(documentSaveOptions);
      if (documentSaveResult.length > 0) {
        const uri = documentSaveResult[0];
        const file = fs.openSync(uri, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
        fs.writeSync(file.fd, content);
        fs.closeSync(file);
        this.controller.runJavaScript(`alert('âœ… å¯¼å‡ºæˆåŠŸï¼');`);
      }
    } catch (error) {
      let err = error as BusinessError;
      this.controller.runJavaScript(`alert('å¯¼å‡ºå¤±è´¥: ${err.message}');`);
    }
  }
}